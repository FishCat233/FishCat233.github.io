<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>写一个 hexo 插件</title>
      <link href="/2025/02/250204/"/>
      <url>/2025/02/250204/</url>
      
        <content type="html"><![CDATA[<h1 id="黑幕-绝对有黑幕">黑幕，绝对有黑幕！</h1><p>今天在尝试美化hexo博客的突然灵光一现，然后就把我之前因为每次都要写 <code>&#123; % raw % &#125;</code> 这样的麻烦的hexo外挂标签语法而不怎么用的黑幕功能做成了插件。</p><p>好吧简单说就是把 <span class="heimu" title="标题在这">这个</span> 写成了一个插件。</p><p>是不是很眼熟？<span class="heimu" title="后面忘了总之加入绝地潜兵">像这样的事情……</span>很正常，因为在萌娘百科就有这样的效果。</p><h1 id="好的-那么我怎么用呢？">好的，那么我怎么用呢？</h1><p>你可以参照<a href="https://github.com/FishCat233/hexo-tag-plugins-heimu">FishCat233/hexo-tag-plugins-heimu: 适用于 Hexo 的黑幕标签插件</a></p><p><strong>或者更加省流一点，在你的 hexo 博客目录执行这个：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-plugins-heimu --save</span><br></pre></td></tr></table></figure><p>然后每当你想用使用黑幕的时候，<code>&#123;%heimu 黑幕内容 标题%&#125;</code> 这样就可以变成 -&gt; <span class="heimu" title="标题">黑幕内容</span>，其中标题可以省略不写，默认的是「你知道的太多了」这个。（或许晚些时候我会写个读取配置的版本能够设置默认标题，但是现在！<span class="heimu" title="你知道的太多了">先鸽！</span>）</p><h1 id="应该不会有人在意的原理吧？">应该不会有人在意的原理吧？</h1><p>查文档呗，看看hexo怎么写插件。首先是hexo自带的功能<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件（Tag Plugins）</a>，也就是<code>&#123;% %&#125;</code>这样的语法。</p><p>然后参照<a href="https://hexo.io/zh-cn/docs/plugins">插件</a>这章知道怎么写脚本。让插件注册一个<a href="https://hexo.io/zh-cn/api/renderer">渲染器</a>来处理自定义的<code>&#123;% heimu %&#125;</code>标签，配合<a href="https://hexo.io/zh-cn/api/injector">注入器（Injector）</a>在网页<head>标签后面注入黑幕配套的css就可以达到这样的效果了。</head></p><p>当然还加入了npm和cdn的要素，不过这都是后话了。</p><p>源代码可以在github上面看。</p><h1 id="实现这个的代价是？">实现这个的代价是？</h1><p><s>代价就是：累坏我了。</s></p><p>代价是不如之前通过修改主题注入css、直接写html那么灵活，因为hexo的标签插件内部不能混合markdown语法。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾博客 </category>
          
          <category> 我的代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> javascript </tag>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone 报错什么 RPC failed 啊怎么办？</title>
      <link href="/2025/02/250203/"/>
      <url>/2025/02/250203/</url>
      
        <content type="html"><![CDATA[<p>在使用conda和pip安装某仓库环境的时候报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8)</span><br><span class="line">  error: 30 bytes of body are still expected</span><br><span class="line">  fetch-pack: unexpected disconnect while reading sideband packet</span><br><span class="line">  fatal: early EOF</span><br><span class="line">  fatal: fetch-pack: invalid index-pack output</span><br></pre></td></tr></table></figure><p>看不懂，干脆问ai，然后在ai的答案里面找到了解药。</p><p>我选择的方法是把http更换成ssh（<a href="https://blog.whispery.top/2025/02/2025020701/">毕竟昨天刚解决ssh的连接问题</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试SSH协议（需提前配置SSH key）</span></span><br><span class="line">git config --global url.<span class="string">&quot;git@github.com:&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span></span><br></pre></td></tr></table></figure><p>然后就，解决了。</p><hr><blockquote><p><em>下面是 DeepSeek 的回答，其中，我采取了更换协议的方法。</em></p></blockquote><p>在安装过程中出现Git相关的网络错误通常与仓库克隆问题或网络连接不稳定有关。以下是分步解决方案：</p><ol><li><p><strong>升级Git和Pip</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新Git配置（针对大仓库）</span></span><br><span class="line">git config --global http.postBuffer 524288000</span><br><span class="line">git config --global core.compression 0</span><br><span class="line"><span class="comment"># 升级pip和工具链</span></span><br><span class="line"></span><br><span class="line"> pip install --upgrade pip setuptools wheel</span><br></pre></td></tr></table></figure></li><li><p><strong>更换Git协议（二选一）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试SSH协议（需提前配置SSH key）</span></span><br><span class="line">git config --global url.<span class="string">&quot;git@github.com:&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或强制使用HTTP/1.1</span></span><br><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure></li><li><p><strong>手动克隆仓库（关键步骤）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先单独克隆主仓库（替换为实际仓库URL）</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yourusername/llava-next.git</span><br><span class="line"><span class="built_in">cd</span> llava-next</span><br><span class="line"><span class="comment"># 初始化子模块（如果有）</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li><li><p><strong>使用镜像源安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目目录中运行（已手动克隆后）</span></span><br><span class="line">pip install -e <span class="string">&quot;.[train]&quot;</span> \</span><br><span class="line"> -i https://pypi.tuna.tsinghua.edu.cn/simple \</span><br><span class="line"> --trusted-host pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure></li><li><p><strong>若仍遇到包下载问题</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对特定包使用镜像源</span></span><br><span class="line">pip install torch torchvision -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure></li></ol><p><strong>其他注意事项：</strong></p><ul><li>确保已安装构建依赖：<code>sudo apt-get install -y git python3-dev python3-venv</code></li><li>如果使用代理，请配置git代理：<code>git config --global http.proxy your_proxy:port</code></li><li>尝试在网络状况较好的时段进行操作</li><li>对于特别大的仓库，可添加<code>--depth 1</code>参数进行浅克隆</li></ul><p>如果问题依旧存在，请提供：</p><ol><li>完整的安装命令输出</li><li><code>pip -V</code> 和 <code>git --version</code> 的版本信息</li><li>是否使用特殊网络环境（公司代理/VPN等）</li></ol><p>这样可以进一步诊断具体问题原因。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 踩坑记录 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/hello-world/"/>
      <url>/2025/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH 连不上 github 怎么办啊？</title>
      <link href="/2025/02/250201/"/>
      <url>/2025/02/250201/</url>
      
        <content type="html"><![CDATA[<p>我不造啊。突然间就连不上了，变量也忒多了，于是不得不花几个钟上网到处找才解决问题。</p><h1 id="代理在干嘛？有没有发力？">代理在干嘛？有没有发力？</h1><p>首先检查的就是代理程序是不是只进行了HTTP代理。虽然暂时不是很懂代理原理，但是显然不对SSH进行代理配置是不行的，于是我上网寻找如何给SSH进行代理。</p><p>忍不住吐槽的是，网上搜出来的东西全是前篇一律：如何在 Mac 上给 ssh 配置代理？如何在 Linux 上给 ssh 配置代理？搜出来的几百篇（夸张）文章都是同一样的图和同一样的命令……甚至同一样的文本（这是真的）。</p><p>在我以为<s>很小众的</s> Windows 用户在这鬼打墙一样的互联网上没有容身之所、要颠沛流离的时候，我找到了<a href="https://blog.imyan.ren/posts/4d70a82d/">这个</a>，跟着博客成功配置了代理。为了防止失联，所以我还是把方法重新整理一下吧。</p><ol><li><p>首先就像正常配置ssh一样打开配置文件。</p><p>什么？你不会？ssh配置文件应该在 <code>~/.ssh</code>(git bash)，或者 <code>C:\Users\用户名\.ssh</code>(Windows) 目录下，这个目录下有个<code>config</code>的文件（细节没有.xxx扩展名，此外如果没有这个文件你可以创建一个）</p></li><li><p>写入配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    ProxyCommand &quot;ProxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect.exe&quot; -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><p>第一行意思是对 <a href="http://github.com">github.com</a> 有效，第二行则是：代理的程序（我这里的<code>connect.exe</code>就是 git bash的东东），-S 代表 Sockets5 代理，然后后面是代理的地址和端口，最后 <code>%h %p</code>照抄就行。</p></li><li><p>保存，然后 <code>ssh -T git@github.com</code>试试，如果正常连接上就说明没问题，你可以收工了。</p></li></ol><h1 id="唉-端口22">唉，端口22</h1><p>如果还有问题——像我一样的<code>kex_exchange_identification: Connection closed by remote host</code>，那你有福了。</p><p>我直接放参考资料吧，最后是我自己的从参考资料里面找到有效的解法：</p><p><a href="https://github.com/orgs/community/discussions/55269">kex_exchange_identification: Connection closed by remote host · community · Discussion #55269</a></p><p><a href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">Using SSH over the HTTPS port - GitHub Docs</a></p><p>你可以试试这条命令是否能连上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>如果能连上那应该用我同样的方法是可以的。简单说就是把 22 端口改成 443 端口，直接改 ssh的 <code>config</code> 就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    ProxyCommand &quot;ProxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect.exe&quot; -S 127.0.0.1:10808 %h %p</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>具体参数意思懒得写了（猜也能猜出来），不懂就问 ai 吧。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 计算机科学 </tag>
            
            <tag> ssh </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剧情情节与矛盾论</title>
      <link href="/2024/10/%E5%89%A7%E6%83%85%E6%83%85%E8%8A%82%E4%B8%8E%E7%9F%9B%E7%9B%BE%E8%AE%BA/"/>
      <url>/2024/10/%E5%89%A7%E6%83%85%E6%83%85%E8%8A%82%E4%B8%8E%E7%9F%9B%E7%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="剧情情节-与-矛盾论">「剧情情节」与「矛盾论」</h1><p>最近看了一篇文章，文章内容讲述关于情节发展和矛盾论的关系，以及如何运用矛盾论来推动剧情。读文后有所感触，故作此文。</p><p>提前打一针预防针，我对矛盾论和剧情情节创作造诣颇浅，如果有误，欢迎指出。</p><h2 id="矛盾论">矛盾论</h2><h3 id="矛盾与-对立与统一">矛盾与「对立与统一」</h3><p>哲学中的「矛盾」显然是和生活用语中的「矛盾」是不同的，因此首先需要说明什么是「矛盾」。「矛盾」是一种关系（也有说是一种状态），不论是关系还是状态，「矛盾」都指向于表达一种事物间的「对立与统一」的关系。在这里，会将矛盾定义为事物间的关一种关系。</p><p>「对立」，指的是矛盾的事物各方相互对立，如同数轴的两头，各占一方。其他事物如同数轴上的点，在一端便不能在另一端，如同正数和负数，没有交集。</p><p>「统一」，或我所习惯的称呼为「相对性」，指的是矛盾的事物各方是相对的，而非绝对的属于任何一方。矛盾各方的对立与正负数这种二元对立不同，各方的对立是相对对立。</p><p>比如说将数轴上的数分为大数和小数，是大数，就不会是小数，但是大小本身是相对的，大是相对大（较大），小是相对小（较小）。组合起来便是矛盾——一种「对立与统一」的关系。</p><h3 id="矛盾的-普遍性">矛盾的「普遍性」</h3><p>矛盾是「普遍的」。矛盾普遍地存在于事物之中，如同数学所表达的关系一样普遍。</p><h3 id="矛盾的发展">矛盾的发展</h3><p>矛盾不会消失，也无法消灭，矛盾以「转化」为主——一个矛盾转化为另一个矛盾，又或是再问题中由主要矛盾变为次要矛盾。</p><h2 id="剧情情节-与-矛盾论">「剧情情节」与「矛盾论」</h2><p>理论是抽象的，回归现实能更好理解。于是这就讨论如何应用矛盾论来辅助情节创作。</p><h3 id="矛盾推动剧情情节">矛盾推动剧情情节</h3><p>直接说答案：矛盾通过产生问题来推动情节。</p><p>矛盾如同地基，有了矛盾就会有问题，有了问题就有主角的动机， 主角去尝试解决不可避的问题，剧情就推动了。</p><h3 id="从普遍的矛盾到有用的矛盾">从普遍的矛盾到有用的矛盾</h3><p>由于矛盾的普遍性，在小说世界中有无数的矛盾，但是对于情节创作来说，往往「较大的矛盾」才能易于为创作所使用。</p><p>例如人与人之间普遍存在的生存竞争——活的好或死的坏。在人人都能被满足时，这个矛盾是「较小的」，人们不会为了生存竞争而相互斗争，也就不会产生「大问题」。而当所有人陷入困境，物质无法满足所有人时，这个矛盾便变得足够大，甚至使得人与人之间相互残杀。就像反派将几个相互至亲之人关入房间，告知只有一人能走出房间一样，人人生存竞争的矛盾由小变大，便有了背叛贪婪等等人人相残的大问题，情节也由此推动了。</p><h3 id="动态的矛盾">动态的矛盾</h3><p>正如先前所说，矛盾是会发展的，会变化的。在主角解决问题后，矛盾不会消失，而是会转化——这也是为什么在看一些小说情节时会发现作者能将一个个问题连在一起。比如说，主角在出手低级越阶斩杀高级角色后，原先的矛盾「高级角色想要杀主角」则可以转化为「主角实力底牌暴露」，又或者「被更强大的角色盯上」，「战后负伤战斗力不断下降」等等。</p><p>总而言之，在解决问题后，原先的矛盾转化为了其他的矛盾，或让它们变大，或让它们变小，而又能产生新的问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编程，还是计算机科学？</title>
      <link href="/2024/07/Coding-or-CS/"/>
      <url>/2024/07/Coding-or-CS/</url>
      
        <content type="html"><![CDATA[<p><em><strong>Whispery 原创，转载请注明作者和博文地址。</strong></em></p><h1 id="在讨论前">在讨论前</h1><p>讨论前，需要明确本文中“计算机科学”和“编程”对应的事物——通常这两个概念是较为抽象的，人与人之间可能会存在相当的理解差别。</p><p>本文中的计算机科学，指代在编程中偏向于理论的部分，也就是计算机相关专业里的那些理论知识，例如考研的408四大件（算法与数据结构、操作系统等等）。</p><p>而编程则对应了做项目敲代码，例如各种框架的掌握，各种编程语言的运用，数据库的使用，做项目所需要了解和掌握的东西。</p><h1 id="programming-or-cs">Programming or CS ?</h1><p>在明确概念后，我们可以开始讨论了。</p><p>我从参考资料（<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">见下</a>）中获得了一些不错的答案，我会将答案和我的理解融合在一起给出我认为的答案。</p><p>结论简单说，就是理论（CS）需要实践（Programming），实践需要理论，两者少其一个都无法成为优秀的程序员。</p><p>如果需要实际一点的最终答案，答案就是这两者是相辅相成的——没有CS知识不影响你成为一名程序员（Programmer），但是没有CS知识你不能称为一名好的程序员；相反地，光有CS知识的人无法成为一名程序员，而有CS知识且保持编程的人可以是一名好的程序员。</p><p>如果你的目的是进行开发，例如较为上层的开发，或许你不是那么需要理论也可以进行开发，你可以毫无顾虑的写网页，使用各种轮子……但是直到你遇见问题，并让你困惑难以解决的时候，你的CS知识（如果有的话）会很好的帮助你度过难关。</p><p>CS知识会帮助我们了解那些在编程语言、框架表面背后的事情是如何运作的，OOP、算法、操作系统……这些知识会帮助我们快速寻找问题背后的本质，以便我们解决问题。</p><h1 id="programming-and-cs">Programming and CS .</h1><p>在参考资料里，我看到了很多很棒的编程哲学，让我大受启发。（尤其是Quora社区的答案）</p><p>在技术飞速进步的当下，盲目着追逐趋势的我们会一步步疲倦，没有对CS的理解，我们只会疲倦地追逐各种新出现地技术，跟随着环境而变化——但是如果我们有一些知识呢？我们可以尝试去理解编程范式地转化（就像当初从机器语言走向面向对象一样），知道新出现的事物本质上和之前有什么不同，能够找到谁才是未来，便可以先一步走在环境的前面。</p><p>而且，作为一名程序员，工作应该是什么？敲代码吗？不，并不是，而是理解人们的问题并找到解决方案。如果认为工作是敲代码——始终以敲代码的方式解决问题，那么你做的结果很可能是将已经造过的轮子重新造了一遍。</p><h1 id="参考资料">参考资料</h1><ol><li>FreeCodeCamp 社区. <a href="https://forum.freecodecamp.org/t/what-should-i-learn-first-cs-or-coding/325569">What should I learn first CS or Coding?</a></li><li>Quora 社区. <a href="https://www.quora.com/How-important-is-it-to-learn-computer-science-first-before-programming">How important is it to learn computer science first before programming?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
          <category> 学习论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 计算机科学 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【持续更新】加糖的CS学习合集</title>
      <link href="/2024/07/CS-Sugar/"/>
      <url>/2024/07/CS-Sugar/</url>
      
        <content type="html"><![CDATA[<p><em><strong>Whispery 原创，转载请注明作者和博文地址。</strong></em></p><p>想写一篇文章记录一下看过的或者听说过感觉比较好的学习计算机的学习资料。</p><p>不过本文不能保证收录完整（这也是合理的），因为不同人对资料的喜好偏好不同，本文记录的资料将具有强烈的个人风格，不喜勿扰。</p><span id="more"></span><hr><h2 id="文字类">文字类</h2><h3 id="微语的闲庭小室"><a href="https://whispery.top/">微语的闲庭小室</a></h3><p>我喜欢这个人。</p><h3 id="linux-c编程一站式学习"><a href="https://akaedu.github.io/book/index.html">Linux C编程一站式学习</a></h3><p>个人心目中无敌水平的中文编程入门书。</p><p>这本书是培训机构教授嵌入式写的书，但是写书的水平相当高，里面有引经据典各种名著，中文写得大白话容易听懂但是又不缺乏深度（例如在goto章节会提及达夫设备（Duff’s device）这段相当语法hack的代码和switch case的实质。</p><p>有c语言、linux脚本还有网络相关的一些部分，个人认为可以当作有一点基础的人进行进一步巩固和理解c语言的好书籍。（目前<br>我只看了c语言部分）</p><p>多加一点，别嫌这本书老，因为这本书真的很好。</p><p>2024-07-29 12:41:55</p><h3 id="hello-算法"><a href="https://www.hello-algo.com/">Hello 算法</a></h3><p>个人心目中无敌水平的中文算法快速入门书。</p><p>这本书意在带读者快速轻松入门算法，因此有着相当棒的、一看就懂的图解来讲算法，有利于快速掌握常见的各种数据结构和算法，达到入门算法的目标。</p><p>个人看这本书的时候因为先前已经看了《图解算法》了，因此看的时候稍微囫囵吞枣了，不过这本书写得还是挺详细的，会给你介绍基本的数据结构和算法，看完这些也算是对算法有一定的了解了。（从无从下手到入门的地步）</p><p>2024-07-29 12:42:08</p><h3 id="代码随想录"><a href="https://programmercarl.com/">代码随想录</a></h3><p>个人搭配上面那个 Hello 算法来学，我一般把这个当习题册，跟着这本习题册逐一的练习和熟悉各种数据结构和算法，不过这本书稍微美中不足的是有时候题解我看不懂（当然这应该是我的缺点）</p><p>但是这本书选的题还是很赞的。</p><p>2024-07-29 12:42:15</p><h3 id="动手学深度学习-2-0"><a href="https://zh-v2.d2l.ai/">动手学深度学习 2.0</a></h3><p>个人心目中无敌的深度学习入门书。（虽然目前我就看过这一本）</p><p>目前看完多层感知机，一路看下来这本书真的在教我怎么整深度学习。这本书偏向于教你怎么做而非带你猛地一头扎入数学和算法的海洋中憋似，但是同时也不乏对一些东西进行解释，让你在会做网络的同时也有一定的理解。</p><p>这本书另一个好处是有着详细的实践教程，甚至配备了jupyter能够让你看。</p><p>同时值得一提的是，这本书作者在b站有号，并录制有<a href="https://space.bilibili.com/1567748478">视频教程</a></p><p>2024-07-29 12:49:28</p><h3 id="图解算法">《图解算法》</h3><p>我看的第一本算法书。用非常简单的方式给我讲解了各种数据结构和算法知识，优点在于这本书看起来非常有趣和轻松，缺点在于稍微有点浅了，而且太薄了（作者要是多写点就好了）</p><p>不过虽然说是薄了点，但是这本书里面还是讲了一些让你看了它的图觉得算法真有意思真奇妙的东西，比如说背包问题，djikstra算法，k近邻算法。</p><h2 id="视频类">视频类</h2><h3 id="learn-go-fast-full-tutorial"><a href="https://www.youtube.com/watch?v=8uiZC0l4Ajw">Learn GO Fast: Full Tutorial</a></h3><p>非常好得go入门视频，适合有一定语言基础的人学习，循序渐进的同时也不缺一些关于底层的讲解。爽赞！</p><p>时不时夹杂的编程梗图也挺难蚌的，总之有基础并且想要快速学习go语言的话，推荐观看。</p><p>2024-08-03 00:49:41</p><h3 id="functional-programming-a-general-introduction"><a href="https://www.youtube.com/watch?v=8z_bUIl_uPo">Functional programming - A general introduction</a></h3><p>不错的讲函数式编程的视频，对函数式编程的思想进行了粗略的讲解。</p><p>这是我看的第一个关于lambda算子的视频，看完这个以后感觉对FP（Functional Programming）有了一定的认识。</p><p>赞。</p><p>2024-08-03 00:52:32</p><h3 id="programming-with-math-the-lambda-calculus"><a href="https://www.youtube.com/watch?v=ViPNHMSUcog">Programming with Math | The Lambda Calculus</a></h3><p>另一期绝赞的讲函数式编程（准确说式lambda算子）的视频。动画做得非常好，讲得也较为循序渐进和易于理解。</p><p>推荐观看。</p><p>2024-08-03 00:54:23</p><h3 id="object-oriented-programming-oop-in-c-course"><a href="https://www.youtube.com/watch?v=wN0x9eZLix4">Object Oriented Programming (OOP) in C++ Course</a></h3><p>C++ 面向对象快速入门，讲得又好又简单，非常推荐。因为偏快速简洁，所以并没有讨论涉及C++ OOP的底层原理（如虚表，函数表之类的）——<em>因此你不会被什么乱七八糟的东西糊脸给搞懵逼。</em></p><p>2024-08-24 18:31:58</p><h2 id="其他类">其他类</h2><h3 id="projected-based-learning"><a href="https://github.com/practical-tutorials/project-based-learning?tab=readme-ov-file#cc">Projected Based Learning</a></h3><p>Github上的项目，基于工程的编程学习，上面有很多可以供初学者学习的项目，并且还按语言进行了分类。</p><p>先前稍微看了点，但是腾不出时间去做，但是单看目录和随便点的几个项目感觉里面的内容还是很不错的。</p><p>……</p><p>看了一些，感觉单个语言上数量不算多，不过质量不错。（看的是go）</p><p>——2024-08-09 16:50:09</p><h3 id="learngitbranch"><a href="https://learngitbranching.js.org/">LearnGitBranch</a></h3><p>交互式学习git怎么用，将git的各种功能分成关卡样式，不错不错。</p><p>——2024-03-09 21:42:08</p><h3 id="regexlearn"><a href="https://regexlearn.com/zh-cn">RegexLearn</a></h3><p>交互式正则表达式学习，跟着学非常轻松。</p><p><strong>对看到大段文字就头晕的人有奇效。</strong></p><p>美中不足的是没有足够的练习题，不过看到主页上面写有练习的界面，应该是没做完练习部分。</p><p>——2024-08-10 21:32:08</p><h3 id="regexone"><a href="https://regexone.com/">RegexOne</a></h3><p>超赞正则表达式学习，内带习题</p><p><a href="https://imageslr.github.io/regexone-cn/resources.html">RegexOne汉化站</a></p><p>汉化站有扩充的进阶章节，会补充一些RegexOne原站没有提及的点。</p><p>——2024-08-10 21:32:22</p><h2 id="没看过的-暂看清单">没看过的（暂看清单）</h2><p>这里顺便记一些没看过的。</p><h3 id="build-your-own-lisp"><a href="https://buildyourownlisp.com/">Build Your Own Lisp</a></h3><p>使用C语言实现“麻雀虽小五脏俱全”的 lisp 语言。中文译版：<a href="https://www.abnerchou.me/BuildYourOwnLispCn/">BuildYourOwnLispCn</a></p><p>暂时没看。</p><h3 id="build-your-own-x"><a href="https://github.com/codecrafters-io/build-your-own-x">Build Your Own X</a></h3><p>Github上的项目，收录了各种手搓xxx项目在里面。什么3d渲染器、git、种子下载器啥乱七八糟的都有。</p><p>没看过。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 计算机科学 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记滑动窗口</title>
      <link href="/2024/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2024/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口法">滑动窗口法</h1><h2 id="所需变量">所需变量</h2><p>滑动窗口由三部分构成：边界，条件相关变量，需求记录变量。</p><h3 id="边界">边界</h3><p>边界由两个指针构成，分别称为左边界和右边界。</p><h3 id="条件相关变量">条件相关变量</h3><p>条件相关变量是用于存储题目所需条件数值的变量。（例如区间和，区间长）</p><h3 id="需求记录变量">需求记录变量</h3><p>需求记录变量是用于算法计划返回的变量，也是题目需求的变量，通常是最大值或最小值（例如区间和最大值，或是满足条件的区间最长长度）</p><h2 id="方法步骤">方法步骤</h2><p><s>听好了，我只写一遍。</s></p><ol><li>所需变量声明</li><li>进行循环，在循环中不断移动右边界，同时不断更新条件相关变量</li><li>在每次移动右边界后，检查条件相关变量是否满足需求记录变量，如果满足则进入另一个循环。</li><li>在另一个循环中，左边界不断移动，更新条件相关变量，记录需求记录变量，直到条件相关变量不满足条件，循环破坏，回到右边界移动的大循环</li><li>需求记录变量为所求</li><li><s>去跟小伙伴们吹逼</s></li></ol><p>更加易懂的代码版本（也就是模板代码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumWindow</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; nums:</span><br><span class="line">    <span class="comment"># 窗口左右边界</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 条件相关变量</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>     <span class="comment"># 以窗口内元素总和为示例</span></span><br><span class="line">    res = <span class="number">0</span>     <span class="comment"># 以求最大元素总和为例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="comment"># 更新值</span></span><br><span class="line">        <span class="built_in">sum</span> += nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果满足条件，则左边界移动，遍历并记录，直至破坏条件</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">            <span class="comment"># 记录最大值</span></span><br><span class="line">            res = <span class="built_in">max</span>(<span class="built_in">sum</span>,res)</span><br><span class="line">            <span class="comment"># 左边界移动，更新 sum</span></span><br><span class="line">            <span class="built_in">sum</span> -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 右边界移动</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res      <span class="comment"># 别高兴到忘了返回...</span></span><br></pre></td></tr></table></figure><h2 id="论为什么滑动窗口比暴力快">论为什么滑动窗口比暴力快</h2><p>猜测上，滑动窗口采用了一种特别的遍历方法，能够在有效排除不符合条件的组合的同时不排除满足条件的组合。</p><p>由于满足条件的数组之间存在有一定相似性，滑动窗口法通过利用这个相似性——在两端移动过程中处于满足条件和不满足条件之间反复横跳，以高效遍历所有可能的组合。</p><h1 id="经典为例">经典为例</h1><blockquote><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code>。</p><p>示例 1：</p><blockquote><p>输入：target = 7, nums = [2,3,1,2,4,3]</p><p>输出：2</p><p>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p></blockquote></blockquote><p>显然可以使用暴力解法，但是本文在此不做提及。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 滑动窗口法</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 左边界</span></span><br><span class="line">        right = <span class="number">0</span>   <span class="comment"># 右边界</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span>     <span class="comment"># 条件相关变量（区间和）</span></span><br><span class="line">        ret = <span class="number">0</span>     <span class="comment"># 需求记录变量（区间和最大值）</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            <span class="comment"># 稳定往窗口加数</span></span><br><span class="line">            <span class="comment"># 右边界无条件移动，并且移动时计算当前的条件相关变量值</span></span><br><span class="line">            <span class="built_in">sum</span> += nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 满足题目条件记录下来，然后 持续 往窗口减数</span></span><br><span class="line">            <span class="comment"># 仅在条件相关变量满足条件时执行，左边界移动，破坏满足的条件，并记录需求记录变量</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                <span class="comment"># 记录</span></span><br><span class="line">                <span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">                    ret = right - left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ret = <span class="built_in">min</span>(ret, right - left)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 减数</span></span><br><span class="line">                <span class="built_in">sum</span> -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数列 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何记笔记</title>
      <link href="/2024/06/%E5%A6%82%E4%BD%95%E8%AE%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/06/%E5%A6%82%E4%BD%95%E8%AE%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="原创不易-转载建议注明作者及出处：-whispery的闲庭小室"><em><strong>原创不易，转载建议注明作者及出处： Whispery的闲庭小室</strong></em></h1><p><em><strong>作者：Whispery</strong></em></p><p><em><strong>原帖地址：<a href="https://whispery.top/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/">https://whispery.top/2024/03/详解极大似然估计和最大后验估计/</a></strong></em></p><hr><h1 id="记笔记的三个原则">记笔记的三个原则</h1><h2 id="原则一：记笔记前提是跟得上讲课的进度">原则一：记笔记前提是跟得上讲课的进度</h2><p>记笔记需要以能跟上讲课进度为前提，如果因为记笔记的速度较慢而错过了新的内容，那么就永远无法跟上讲课进度。这是记笔记的前提。</p><h2 id="原则二：事后一定能回忆起来讲过什么">原则二：事后一定能回忆起来讲过什么</h2><p>笔记是用来方便记忆和回忆的，因此如果记录的笔记不能起到方便记忆和回忆的效果，那么笔记便难以为己所用。这是记笔记根本的效益。</p><h2 id="原则三：学会偷懒记笔记">原则三：学会偷懒记笔记</h2><p>自己的笔记是给自己用的，因此不用去考虑别人能不能看懂，只要自己能看懂就行，要学会偷懒。如果顾这顾那，必定会减慢笔记速度。字可以潦草，只要自己看得懂就行；图案可以简略，只要自己能理解就行。简单说，笔记是高度个人定制化的、给现在和未来学习生活中的自己用的私人物品。</p><h1 id="记笔记的两个花招">记笔记的两个花招</h1><h2 id="留下疑问">留下疑问</h2><p>在笔记上除了记录学到的知识以外，也可以写下学习中的疑问。当正在上课的时候，脑海中却冒出了疑问，如果这个时候去探求疑问的话，那就势必脱离课堂——因此我们可以将疑问写在笔记上，更有时间还可以草草写下一些思路，或在课后有时间进行探求或询问他人老师。</p><h2 id="有趣化">有趣化</h2><p>记笔记不应该被视作一种任务，如果觉得无聊，或许可以用不同颜色的笔来增加趣味性。<span class="heimu" title="你知道的太多了"><s>（不过个人感觉记笔记本身并不无聊，觉得无聊或许是因为认为笔记本身是一件被动的学习任务）</s></span></p><h1 id="个人感受">个人感受</h1><h2 id="笔记的本质与核心">笔记的本质与核心</h2><p>一种基于个人的高度定制化的辅助记忆回忆的思想工具，抑或是文字形式。核心在于在学习新知识或者复习旧知识的过程中辅助记忆和回忆。</p>]]></content>
      
      
      <categories>
          
          <category> 元学习 </category>
          
          <category> 学习论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 学习论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记渲染管线</title>
      <link href="/2024/03/%E5%B0%8F%E8%AE%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2024/03/%E5%B0%8F%E8%AE%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>小记渲染管线，不会涉及复杂的底层原理，仅供简单概念理解。</p><p>本文将以游戏中常见的3D模型渲染出画面的过程为例，讲述什么是渲染管线。</p><h1 id="在了解渲染管线前">在了解渲染管线前</h1><p>在电脑中，整个绘制工作一般由CPU指挥GPU进行——CPU会提供具体任务和数据，而GPU负责执行和计算。</p><h2 id="为了绘制所要准备的那些数据">为了绘制所要准备的那些数据</h2><p>电脑所要渲染的三维物体，其实是由模型和材质贴图构成，而模型在电脑中则是由一个个点以及点上的数据（例如uv信息、法线等等），这些数据被称为<strong>顶点缓存（Vertex Buffer）</strong>。</p><p>由点可以构成面，但是很多面都是形状各异的，为此可以通过顶点组合的方式将面分成数个三角形面进行绘制，例如一个正方形可以通过选中4个顶点的3个绘制三角形，然后再绘制另一个三角形，组合起来便可形成一个完整的正方形，这样所有形状各异的面都会被分割成为数个可以绘制的三角形。</p><p>不过因为分解和绘制是分开的（CPU不会进行绘制），因此和顶点缓存一样，分出来的三角面的数据也要存储，具体些则是顶点组合需要存储，而在顶点组合中，记录的不是具体顶点的坐标，而是顶点的索引（代号），因此存储的数据会被称为<strong>索引缓冲（Index Buffer）</strong>。</p><p>除此之外，在游戏中还有摄像机相关的数据以及光照相关的数据需要一并准备。</p><p>还有一个更重要且较为耳熟能详的东西，就是着色器（Shader）——可以草率理解为一些用于对模型贴图进行处理的代码脚本。也是在绘制前需要准备的数据。</p><h1 id="渲染管线">渲染管线</h1><p>从CPU将绘制所需要的数据给GPU后，GPU通过对数据的处理并绘制的过程，则是<strong>渲染管线</strong>。</p><p>值得一提的是，广义上的渲染管线也包括了CPU准备数据的阶段。</p><h2 id="开始绘制">开始绘制</h2><p>GPU收到了CPU的数据，开始绘制，其中有几个重要的流程，下面会按顺序进行介绍。</p><h3 id="顶点着色-vertex-shader">顶点着色 Vertex Shader</h3><p>在这一步，GPU会按照着色器里写的脚本对顶点缓冲里的数据进行额外处理。例如将模型的顶点坐标变换为屏幕上的坐标。</p><h3 id="triangle-processing">Triangle Processing</h3><p>在这一步，GPU会绘制上面提到的三角形面。</p><h3 id="光栅化-rasterization">光栅化 Rasterization</h3><p>因为屏幕是一个个像素组成，因此GPU会将三角面变为具体的像素。</p><p>同时在这一步GPU会进行深度测试——也就是判断三角面之前的遮挡关系。</p><h3 id="像素着色-pixel-shader">像素着色 Pixel Shader</h3><p>在这一步，GPU会根据Shader给模型上材质或者是上光影效果。</p><h3 id="frame-buffer">Frame Buffer</h3><p>在这一步，GPU会添加一些后处理手段，例如抗锯齿、辉光之类的效果。</p><h1 id="参考文章">参考文章</h1><p>业余蚊子.<a href="https://www.bilibili.com/video/BV1qY4y1V79z/">【游戏开发基础知识】什么是渲染管线？如何绘制3D物体？</a></p>]]></content>
      
      
      <categories>
          
          <category> 小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习三要素</title>
      <link href="/2024/03/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B8%89%E8%A6%81%E7%B4%A0/"/>
      <url>/2024/03/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B8%89%E8%A6%81%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>《统计学习方法》读书小记 其一。</p><p><em><strong>Whispery 原创，转载请注明作者和博文地址。</strong></em></p><h1 id="统计学习三要素">统计学习三要素</h1><p>统计学习方法都是由 <strong>模型、策略和算法</strong> 构成的，这就是统计学习三要素，它们之间的关系可以表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>方法</mtext><mo>=</mo><mtext>模型</mtext><mo>+</mo><mtext>策略</mtext><mo>+</mo><mtext>算法</mtext></mrow><annotation encoding="application/x-tex">方法 = 模型 + 策略 + 算法 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">方法</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">模型</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">策略</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">算法</span></span></span></span></span></p><h2 id="模型">模型</h2><p>在监督学习中，模型就是所要学习（模仿）的条件概率分布或决策函数。</p><p>在参考文章中看到一个很通俗的例子来解释什么是模型：</p><blockquote><p>想象你正在尝试为一堆乱飞的鸟找一个轨迹。模型就像你选择的特定的路径或形状，例如你认为它们是按照直线、圆形或某种波浪线飞行。</p></blockquote><p><strong>模型是对现象背后原理的猜想。</strong></p><p>而模型多是带有参数的，不同参数可以产生不同效果的模型，<strong>而所有参数各自的模型的总和则构成了假设空间。</strong></p><p>借上面那个乱飞鸟的例子，例如模型（猜想）是鸟是匀速圆形飞行的，那么参数就可以是圆形的半径，鸟的速度。不同的半径和速度构成的具体轨迹都是不同的，因此对鸟飞行轨迹的预测产生了不同的结果，而所有半径和速度可能取得的值的组合所产生的多个模型构成的总和就是假设空间。</p><h2 id="策略">策略</h2><p>策略，即模型的学习策略，换句话说是从假设空间中所有可能的模型里挑选模型的策略。</p><p>目标是选择最优的模型，也就是最能准确预测乱飞鸟轨迹的模型。</p><p>假设空间里面充斥着各种参数组合产生的模型，我们可以通过对比各种模型所给出的预测值和真实值的差距来筛选出最优的模型。<strong>这个用于计算预测值和真实值差距的函数就是损失函数——又或叫代价函数。</strong></p><p>损失函数可以用来测量模型的错误程度，从而评估模型的准确度。</p><p>不过单计算当前情况下的损失值是不够的，因为由于实际情况下多变复杂，不同情况下同一个模型的损失（即错误程度）可能不同，因此应该考虑在所有情况下损失都能维持较小的模型——也就是令损失函数期望值较小的模型。</p><p><strong>损失函数的期望值代表了所有情况下的平均意义下的损失，称为期望损失或风险函数。</strong></p><p>依然是借用参考文章中的例子：</p><blockquote><p>想象你和朋友们在野外，大家在玩一个游戏——用纸飞机比赛看谁飞得远。你观察每个人怎么折纸飞机、怎么扔、飞机的大小和形状等等。你把所有这些观察到的信息，形成了一种“理论”或“想法”来预测下一次纸飞机飞行的距离——这是模型。</p></blockquote><p>而策略则是评估模型的方法，例如你决定采用“每次预测距离和实际飞行距离的差值”来评估当前模型的好坏（也就是当前模型参数的好坏）——这个算差值来评估模型的方法就是损失函数。</p><p>但是不可能简简单单的根据飞一次的差值来评估自己的“理论”（模型）的好坏，因为有可能不同情况下不同“理论”的适用程度不同，这个模型能预测好这次的飞行，但不一定能预测好下一次的飞行。</p><p>因此你会考虑记录多次飞行的结果和预测结果的差值，最终算出各个模型差值的平均数，然后选平均差值最小的那个。</p><p>这个平均差值就是期望损失（风险函数）。</p><h2 id="算法">算法</h2><p>算法是学习的主干，在确定模型和评估模型好坏的方法（策略）后，<strong>还需要一个寻找最优模型的方法——这就是算法。</strong></p><p>例如在上面的纸飞机中，你可以随便选参数一个个评估来寻找最好的“理论”（不过那样会很慢！），也可以一步步的让参数递增来寻找。</p><h1 id="三要素与统计学习方法">三要素与统计学习方法</h1><blockquote><p>统计学习方法之间的不同，主要来自于模型、策略、算法的不同。确定了模型、策略、算法，统计学习方法也就确定了。</p></blockquote><h1 id="后话-博主的话">后话（博主的话）</h1><p>作为小记，我尽量使用了较为简洁的语言去阐明三者的关系，但是受限于我个人的理解水平和表述水平，有些地方可能还是勉勉强强甚至有理解错误的情况，因此如果有听不懂的，可以在试着在评论区问，看到了的我应该会回。</p><hr><h1 id="参考文章">参考文章</h1><p>农凡.<a href="https://zhuanlan.zhihu.com/p/654174621">1-3 统计学习三要素(模型、策略与算法)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
          <category> 算法 </category>
          
          <category> 数学王国 </category>
          
          <category> 概率统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 读书小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热烈庆祝博客1000天——</title>
      <link href="/2024/03/%E7%83%AD%E7%83%88%E5%BA%86%E7%A5%9D%E5%8D%9A%E5%AE%A21000%E5%A4%A9/"/>
      <url>/2024/03/%E7%83%AD%E7%83%88%E5%BA%86%E7%A5%9D%E5%8D%9A%E5%AE%A21000%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>啊？这就1000天了？</p><hr><h1 id="疑惑">疑惑</h1><p>我相信绝大多数<span class="heimu" title="你知道的太多了"><s>（其实是100%）</s></span>的人都有对标题有疑问：</p><p><strong>最近<span class="heimu" title="你知道的太多了"><s>（前天/昨天）</s></span>才刚听说你小子的博客，今天就告诉我你的博客1000天了？？？</strong></p><p>得得得，其实是我在吹逼了<span class="heimu" title="你知道的太多了"><s>标题党</s></span>，事情是这样：</p><p>对于这个新博客来说，今天确实是第三天，拿出来给人看的第二天。而对于295天前左右听说我在折腾博客的人来说，这是第295天。对于1000天前听说我在尝试建站的人来说，这是第1000天。</p><p>好吧其实后面两类人除了我一个人也没有——因为<span class="heimu" title="你知道的太多了"><s>害羞</s></span>当时还搞不懂建站的七七八八就搁置了，并且我也没有什么想写的东西。</p><p>写一篇博文纪念一下过去吧，至少如今实现了以前的愿想——虽然不知道会持续多久。</p><h1 id="wordpress-与-那年的我">Wordpress 与 那年的我</h1><p>今天是2024年3月10日，在1000天前，也就是2021年6月14日，在那个无聊的暑假<span class="heimu" title="你知道的太多了"><s>也许是暑假吧</s></span>，<span class="heimu" title="你知道的太多了">由于现实条件受限</span>，我折腾起ksweb——一款将手机变为服务器搭建web环境，在我的手机上面，我跑起了 Wordpress 来当我的博客，但是因为我对于网络和建站的相关知识完完全全是零，并且我因为是学生党，资金匮乏，最终在一番折腾以后，因为没有域名的问题以及各种让我头疼的技术问题，这个博客不得不搁置了起来。</p><p>我因为ksweb了解到了Wordpress，又因Wordpress了解到了“个人博客”这个概念。</p><p>在2022年的某天<span class="heimu" title="你知道的太多了">（我也不记得哪天了，后续我再从日记里查证吧）</span>，我从网上了解到了有大佬做二级域名的分发（迷迭香的二级域名），在这里感谢那个大佬。虽然到最后我也不懂那个域名怎么用，只是按着网上的教程照猫画虎、瞎猫碰死耗子地瞎配置，花了很多精力以后，最后才成功。</p><p>尽管配置成了，但是因为要用手机保持web服务器运行以及公网ip（那个时候我远程访问靠的都是ipv6），再加上我折腾个人博客的主要原因只是折腾而不是真的想要去做个人博客（虽然我在做的时候告诉我我可以写点东西到这个博客里面，但是最后还是没有什么想写的东西）</p><p>所以我很快就把注意力放到了搭建个人博客以外的事情上，因此这个项目彻底搁置了，甚至随着时间渐渐沉入了记忆的深处，被遗忘了。</p><p>直到我今天在图床网站上看到了2021年上传的图片才想起来这个博客。</p><h1 id="初见-hexo-github-pages">初见 Hexo，Github Pages</h1><p>2024年5月20日，我从一个本地知名学校的匿名墙网站上了解到了 Hexo 和 Github Pages 这两样东西，当我知道 Hexo 可以用来做个人博客，而且 Hexo 搭配 Github Pages 的方案还是免费时，我 belike：</p><p>个人博客，我来啦！</p><p>——当时我大概是这么想的，总之动手就做，反复折腾，来回试了很多个主题，比如说 Icarus、NexT、Butterfly ，不过我的相关技术知识还是很贫弱，当时为了能研究怎么插入本地图片，我折腾了好几天也没搞清楚，最后就搁置了。</p><p>一是没法插入本地图片，我也不喜欢什么都传到图床，再是我还是不知道我写什么、该怎么写，所以多个因素叠加的最终结果就是——</p><p><strong>鸽了！</strong></p><p>不过是 Hexo &amp; Github Pages 的组合，网站还是在的。</p><h1 id="现在-实现最初的愿景">现在 实现最初的愿景</h1><p>很庆幸我前些天产生了“我要不要重新折腾博客”的想法，不然也不会看到博客现在的样子。</p><p>虽然我还是学生，但是现在的我相比当初，有了一小部分省下来的闲钱可以去做到一些简单的事情，这些年折腾的结果，包括我主动学习了解了一些相关知识，也能简单地去折腾博客了——至少比当时只会循规蹈矩的跟着教程，我有了能自己查证部分出错原因的能力。</p><p>还等什么，动手做！——域名？买！域名记录？做！CDN？配！博文？写！</p><p>这就是这个博客现在的形态，有如当年我所期望的形态：一个属于自己的博客，上面写着一些自己觉得很棒的文章，记着很酷的事情。</p><h1 id="在未来">在未来</h1><p>距离那年初见已经 1000 天了，不禁有些感慨了。在多年后，不只是博客，当年那些我所期望的觉得很酷很赞的事情，我现在正在或有意识或无意识中一个个实现。</p><p>我觉得与其说无意识，倒不如说是我当时的那颗心——初心沉入了记忆深处，或许我忘了当时自己的那些折腾，吃的那些错误，花上好久去尝试处理一个现在看起来很简单的错误的过程，但是我依然记得“我想要做这个”这个愿望。</p><p>幸运的是，未来的我实现了过去的我的愿望。</p>]]></content>
      
      
      <categories>
          
          <category> 博客公告 </category>
          
          <category> 人生史书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 公告 </tag>
            
            <tag> 人生史书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解极大似然估计和最大后验估计</title>
      <link href="/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/"/>
      <url>/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>最大似然估计（Maximum likelihood estimation, MLE）</strong> 和 <strong>最大后验概率估计（Maximum a posteriori estimation, MAP）</strong> 是很常用的两种参数估计方法。本文将详解MLE和MAP的思路和区别。</p><span id="more"></span><h1 id="原创不易-转载请注明作者及出处：-whispery的闲庭小室"><em><strong>原创不易，转载请注明作者及出处： Whispery的闲庭小室</strong></em></h1><p><em><strong>作者：Whispery</strong></em></p><p><em><strong>原帖地址：<a href="https://whispery.top/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/">https://whispery.top/2024/03/详解极大似然估计和最大后验估计/</a></strong></em></p><hr><h1 id="在此之前">在此之前</h1><h2 id="概率与统计">概率与统计</h2><p>首先我们要搞清楚MLE和MAP到底是什么方法，研究什么问题，用途是什么。而在此前要了解概率和统计的区别。</p><p>概率和统计是关系密切的概念，但是两者对问题的关注方向不同。</p><p>网上关于两者的关系和区别有很多说法和比喻，我在这里说一下我个人的理解： <strong>概率关注问题的结果，统计关注问题的过程。</strong></p><p>比如说，我有一个随机数生成器，它的原理是以某种特定的方法生成0或1，概率学会关注生成0或1的概率，而统计学会关注生成结果的方法——也就是生成随机数的过程。</p><p>上面的例子可能还是有点绕，不如更现实一些。例如学校课堂上老师用座位表随机点人，问题是我会不会被老师点到，那么概率学会关注我有多少可能会被点，而统计会关注老师点人的习惯特点（例如老师因为右手拿座位表手指会挡住一些人名导致那个位置的人几乎不会被点）</p><p>回到MLE和MAP上，MLE和MAP是统计领域的问题，这两种方法能够根据统计估计假设模型中的参数。</p><h2 id="贝叶斯定理">贝叶斯定理</h2><p>在了解MLE和MAP之前，你还得了解 <strong>贝叶斯定理（Bayes’ Theorem）</strong> ：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(A|B)=\frac{P(B|A)P(A)}{P(B)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>别慌，贝叶斯定理其实是条件概率和联合概率公式推来的。</p><p>我们可以浅显的从现实去看这个公式——假设在小区的白天，电动车响了，会不会是有人在偷车？令有人在偷车为事件A，电动车响了为事件B。等式左边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A|B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>表示电动车响是有人在偷车的概率；等式右边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B|A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>表示有人偷车的时候电动车响了，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>表示有人在偷车，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>表示电动车响了。</p><p>当电动车发出声响的时候，大部分人都不会觉得是有人在偷车，为什么呢？因为我们知道：虽然<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B|A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>偷车的时候电动车会响的概率很大，但是有人偷电动车这一事件发生<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>的概率本身会较小，而且同时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>电动车会响的事情会很大——电动车发出响声再平常不过了。因此总体而言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A|B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>的概率就小了，也就是电动车响了的时候有人在偷车的概率小了。</p><p>回到公式上，贝叶斯定理描述了 <strong>在考虑事情本身发生及其前提发生的可能性后，发生的概率会有多大？</strong> ，或者说： <strong>你有多大把握相信一件事会发生。</strong></p><p>还不理解？不妨将上面那个例子设置得极端一些：假如说世道混乱，<span class="heimu" title="民 风 淳 朴"><s>民风淳朴</s></span>，你觉得偷电动车再常见不过，那么在你眼里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>有人偷电动车的概率很大，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A|B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>总体就会更大了。又或者小区里的电动车都很乖，平时正常使用都不怎么响的，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>电动车响声的概率就很小，总体而言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A|B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>总体就会更大，当响声时你也会觉得是不是有人在偷车。又或者知道电动车的警报系统很拉跨，很多时候即使有人偷车也不会响，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B|A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>很小，那么总体而言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A|B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>变小，偶尔响一下也不会觉得是有人在偷车，因为觉得大部分小偷偷车的时候都不响，警报系统没有可信度，现在响也不能证明有人在偷车。</p><p>这就是我关于现实视角下的贝叶斯定理的解释和理解。</p><h2 id="似然函数">似然函数</h2><p>极大似然估计（MLE），我们可以猜，极大就是最大值或者很大数的意思，而估计则可以从概率与统计中得到答案——估计模型的参数……那么，似然是什么？</p><p>为此，要说说似然函数。</p><p>在<a href="https://blog.csdn.net/u011508640/article/details/72815981">参考文章</a>里，我找到了一个很好的解释。</p><blockquote><p>似然（likelihood）这个词其实和概率（probability）是差不多的意思，Colins字典这么解释：The likelihood of something happening is how likely it is to happen. 你把likelihood换成probability，这解释也读得通。但是在统计里面，似然函数和概率函数却是两个不同的概念（其实也很相近就是了）。</p><p>对于这个函数（或者你可以理解为一个抽象没有具体形态的方程，描述了模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 和结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的关系）：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></p><p>输入有两个：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>表示某一个具体的数据； <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 表示模型的参数。</p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 是已知确定的，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>是变量，这个函数叫做概率函数(probability function)，它描述对于不同的样本点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，其出现概率是多少。</p><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>是已知确定的， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 是变量，这个函数叫做似然函数(likelihood function), 它描述对于不同的模型参数，出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>这个样本点的概率是多少。</p></blockquote><p>可以回到上面那个关于概率和统计那个随机数生成器的例子，生成器随机生成0和1，我们假设生成器用的是某种模型，然后模型通过一个参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 随机生成0和1。那么当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 已知时，令生成的结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>为变量，这时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>就是概率函数，描述了0和1出现的概率分布。而当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>已知时，令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 为变量，这时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>就是似然函数，其表述了在生成器设置不同的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 下，已知的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>出现的概率。</p><h1 id="mle与map">MLE与MAP</h1><h2 id="最大似然估计-mle">最大似然估计 MLE</h2><p>终于要写这部分了。</p><p>想象面前有两个箱子，一个箱子装满了红球，一个箱子装满了白球。</p><p>再想象我们有台机器，它会按照随机地从两个箱子里抽出一个球。</p><p>我们先假设一个简单的模型来描述这个过程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>机器选择抽红球</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>θ</mi><mo>&gt;</mo><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>机器选择抽白球</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>&gt;</mo><mi>x</mi><mo>&gt;</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\begin{cases}机器选择抽红球, &amp; \theta &gt; x &gt; 0 \\机器选择抽白球, &amp; 1 &gt; x &gt; \theta \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">机器选择抽红球</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">机器选择抽白球</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>机器产生从0到1的随机数x，然后判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>是比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 大还是小来决定是抽红球还是白球。</p><p><strong>问题来了，我们怎么找到最切合实际的模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 呢？</strong></p><p>答案是通过实际实验来找。</p><p>那么现在开始抽球，让机器抽了10个球，实验结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是：红白红红白红白白红红。</p><p>回到先前那个奇怪的函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，在抽象层面上，现在我们知道了结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，可以通过这个函数（方程）求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ——不过在此之前，我们要先求出这个函数在当前问题下的具体形式才能进行求解——也就是求出出现实验结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的似然函数。</p><p>根据上面假设的模型，我们知道这是简单的几何概型（不知道几何概型也没关系），抽出红球的概率是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，抽出白球的概率是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">1-\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，那么出现结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的似然函数可以简单的推导出来：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>×</mo><mi>θ</mi><mo>×</mo><mi>θ</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>×</mo><mi>θ</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>×</mo><mi>θ</mi><mo>×</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">P(x_0|\theta)=\theta\times(1-\theta)\times\theta\times\theta\times(1-\theta)\times\theta\times(1-\theta)\times(1-\theta)\times\theta\times\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></p><p>化简得</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>θ</mi><mn>6</mn></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><msup><mo stretchy="false">)</mo><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">P(x_0|\theta)=\theta^6(1-\theta)^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><p>这就是结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时关于变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 似然函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>在我们假设的模型中则是模型的参数，我们可以画出函数图来看一下这玩意长什么样。</p><p><img src="/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0.png" alt="函数图像"></p><p>长这样。</p><p>横轴是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，而纵轴则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x_0|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，也就是在不同 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 下出现抽球结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （注意在上面的求似然函数的过程中，我们考虑了全部十次抽球结果， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 代表了十次结果整体而不是分开的一次次结果）的概率。</p><p>我们可以发现，当模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.0011944</mn></mrow><annotation encoding="application/x-tex">0.0011944</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0011944</span></span></span></span>时，抽球抽出结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的概率最大。</p><p><strong>也就是说，我们模型里的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 为0.0011944时，最贴合实验结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。通过似然函数和已知的实验结果，求似然函数最大值对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的方法，我们知道了给模型取什么样的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 最能贴合实验结果的方法，这个方法就是最大似然估计MLE。</strong></p><h2 id="最大后验概率估计">最大后验概率估计</h2><p>好消息，<span class="heimu" title="你知道的太多了"><s>在特异能力者对机器的读心实验中</s></span>，我们知道了更多关于这台机器的情报，我们知道模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 更有可能会是0.3——我们得到了关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的概率分布函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，这个函数告诉了我们实际的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 有可能会是什么，也就是“ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 等于某个数x”成立的概率，根据情报，我们知道了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>a</mi></mrow></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><msup><mrow><mo fence="true">(</mo><mi>x</mi><mo>−</mo><mi>b</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>a</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(\theta)=\frac{1}{\sqrt{2\pi}a}\exp\left(-\frac{\left(x-b\right)^{2}}{2a^{2}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.551em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1089em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>。</p><p>长这样：</p><p><img src="/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87.png" alt="函数图像"></p><p>好吧这里面有很多槽点和漏洞，但是让我们别管它们！</p><p>我们该怎么把新得到的情报引入我们的最大似然估计呢？答案是贝叶斯定理！<strong>在考虑事情本身发生及其前提发生的可能性后，发生的概率会有多大？</strong>——我们不只参考了实验结果，也参考了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 本身等于某个数的概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>。</p><p>在最大似然估计中，我们通过取最大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>来获得最切合的模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，我们可以用条件概率表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>当实验结果为x时参数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的概率。</p><p>根据贝叶斯定理，可知：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(\theta|x)=\frac{P(x|\theta)P(\theta)}{P(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>函数值最大的时候，也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 最有可能取得的数。因此我们找到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>最大时对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 就可以求得在考虑了新情报的情况下最合适实验结果的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 。</p><p>在实际问题中我们已知实验结果，变量时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>为定量，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>也为定量，因此想找等式左边的最大值，只需要关注右边分子的最大值，问题变成了找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>最大时对应的x。</p><p>在前面我们知道了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>θ</mi><mn>6</mn></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>θ</mi><msup><mo stretchy="false">)</mo><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">P(x_0|\theta)=\theta^6(1-\theta)^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>，根据后来的情报我们又知道了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>a</mi></mrow></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><msup><mrow><mo fence="true">(</mo><mi>x</mi><mo>−</mo><mi>b</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>a</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(\theta)=\frac{1}{\sqrt{2\pi}a}\exp\left(-\frac{\left(x-b\right)^{2}}{2a^{2}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.551em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1089em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x|\theta)P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>不就是将两者乘起来了嘛！<span class="heimu" title="你知道的太多了">通过计算机</span>轻松画出函数图像找到最大值。（其实在实际计算中不用画图像也能求最大值）</p><p><img src="/2024/03/%E8%AF%A6%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87.png" alt="后验概率"></p><p>我们可以找到函数最大时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 对应的值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.581</mn></mrow><annotation encoding="application/x-tex">0.581</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.581</span></span></span></span>。</p><p>这就是考虑了新情报以后最切合实验结果的模型参数。</p><p>回到上面的公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(\theta|x)=\frac{P(x|\theta)P(\theta)}{P(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 上，根据先验概率和后验概率的定义，我们知道在公式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>是先验概率，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>是后验概率。在我们上面求最切合的模型参数的方法里，我们把求最切合模型参数的问题转换成了求解后验概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的最大值的问题——这就是“最大后验估计”。</p><h1 id="后话">后话</h1><p>需要知道的是，不管是最大似然估计还是最大后验估计，我们都是在求我们所假设的模型的最佳参数，由于模型本身是假设的，所以结果可不可靠除了参数以外，也要选择切合实际的模型。在上面的例子中，万一机器抽球原理不是我们假设的模型而是其他的呢？</p><p>而在最大后验估计中，“新情报”（也就是先验概率）的可靠程度也影响了最大后验估计的结果，有时候不一定是什么都加入考虑加入计算就能得出最贴合实际的模型和参数。同样还是上面那个例子，如果异能者为了拖延我们对机器的研究，故意造假给出了先验概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>呢，那么我们的计算结果就会受到假信息的干扰，从而难以得到正确的结果。</p><p><span class="heimu" title="你知道的太多了"><s>或许我们应该调查一下那一名异能者。</s></span></p><hr><h1 id="参考文章">参考文章</h1><ul><li><a href="https://blog.csdn.net/u011508640/article/details/72815981">详解最大似然估计（MLE）、最大后验概率估计（MAP），以及贝叶斯公式的理解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
          <category> 算法 </category>
          
          <category> 数学王国 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【持续更新】好用资源合集</title>
      <link href="/2024/03/%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91%E5%A5%BD%E7%94%A8%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/"/>
      <url>/2024/03/%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91%E5%A5%BD%E7%94%A8%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>这篇文章会记录值得记下的软件和资产资源、还有乱七八糟的网站。</p><h2 id="more"><span id="more"></span></h2><h2 id="软件">软件</h2><h3 id="okular"><a href="https://okular.kde.org/">Okular</a></h3><p>好用的电子书阅读器，拿来看pdf和epub挺方便。</p><hr><h2 id="资产资源">资产资源</h2><h3 id="霞鹜文楷系列">霞鹜文楷系列</h3><p>霞鹜文楷是一款开源中文字体，基于 FONTWORKS 出品字体 Klee One 衍生。</p><p><img src="/2024/03/%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91%E5%A5%BD%E7%94%A8%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/wenkai-1.png" alt="霞鹜文楷"></p><p>Github: <a href="https://github.com/lxgw/LxgwWenKai">https://github.com/lxgw/LxgwWenKai</a></p><hr><h2 id="网站">网站</h2><h3 id="中科大测速站"><a href="https://test.ustc.edu.cn/">中科大测速站</a></h3><p>如名，用来测网速的。</p><h3 id="下载"><a href="https://d.serctl.com/">下载</a></h3><p>能够用来加速下载github的文件。</p><p>不过最近似乎是调整了下载速度，感觉没以前快了，不过还挺好用。</p><h3 id="github-文件加速"><a href="https://gh.api.99988866.xyz/">GitHub 文件加速</a></h3><p>似乎是挂了。</p><h3 id="github-加速下载"><a href="https://github.ur1.fun/">Github 加速下载</a></h3><p>速度还可以。</p><h3 id="defuse-online-x86-x64-assembler-and-disassembler"><a href="https://defuse.ca/online-x86-assembler.htm#disassembly">Defuse Online x86 / x64 Assembler and Disassembler</a></h3><p>挺好用的，可以把x86和x64汇编代码和十六进制进行相互转换。这个<a href="https://defuse.ca">网站</a>还有其他的工具看起来也挺好使的，速度很快。</p><h3 id="online-assembler-and-disassembler"><a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">Online Assembler and Disassembler</a></h3><p>相比上面那个汇编十六进制的网站，这个架构选择会多很多，功能选项比较多，不过国内访问比较慢。</p><h3 id="积分分步计算器"><a href="https://mathdf.com/int/cn/">积分分步计算器</a></h3><p>能够分步算出积分的计算器，挺高级。</p><h3 id="learn-git-branching"><a href="https://learngitbranching.js.org/">Learn Git Branching</a></h3><p>以游戏的方式学会 git 的简单使用方式。</p><p>倒也没游戏那么夸张，不过你可以当作是游戏——通过一关关讲清楚git的基本使用方式如（rebase commit等等），不说能记住多少，学完基本能对git有个了解。</p><p>最赞的是这个网站对git版本控制的可视化，学起来很容易理解。</p><h3 id="regex正则表达式在线测试"><a href="https://www.mklab.cn/utils/regex">Regex正则表达式在线测试</a></h3><p>可视化的、在线的正则表的是测试工具。</p><p>可视化相当不错。</p><h3 id="ooee收藏夹"><a href="https://www.oedh.net/">OOEE收藏夹</a></h3><p>记录了各种网站，几年前经常从上面找网站来看番。</p><p>吹个逼，n年前我给站长建议加上某个番剧资源网站，很快那站长就加了，好评。</p><p>虽然叫OOEE收藏夹，但是地址是 <a href="http://www.oedh.net">www.oedh.net</a> ——原先那个ooee的域名过期了。</p><h3 id="下次一定-cn"><a href="https://www.iiice.cn/">下次一定.cn</a></h3><p>资源站，虽然不怎么用，但是看着感觉挺全的。</p><hr><h2 id="杂类-并不是推荐-只是博主收藏">杂类（并不是推荐，只是博主收藏）</h2><h3 id="绘迷"><a href="https://enazo.cn/">绘迷</a></h3><p>你画我猜。</p><h3 id="雨世界地图"><a href="https://rain-world-map.gitee.io/index.html">雨世界地图</a></h3><p>雨世界地图，DLC的蛞蝓猫的地图也有，标注信息很详细。</p><h3 id="随机地名生成器"><a href="https://thestoryshack.com/zh/tools/place-name-generators/">随机地名生成器</a></h3><p>写小说实在不知道起什么名的时候会参考。</p><h3 id="挂刀行情站"><a href="https://steam.iflow.work/">挂刀行情站</a></h3><p>如题。</p><h3 id="roll20"><a href="https://roll20.net/">Roll20</a></h3><p>跑团工具。没用过，只是记一下。</p><h3 id="纯美苹果园"><a href="http://bbs.goddessfantasy.net/bbs/">纯美苹果园</a></h3><p>TRPG游戏网络论坛。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析</title>
      <link href="/2024/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>我最近买了个域名（whispery.top），在域名注册商那里配置的时候看到了一些参数，好奇的查了一下，在这里小记一下查询到的简单解释。</p><span id="more"></span><hr><p>下面会以我的域名 whispery.top 为前提讲解。</p><h2 id="hostname-域名">HOSTNAME 域名</h2><p>主要是操作下级域名的规则，例如我有 whispery.top 域名，在配置界面一条记录中的hostname设置为www，那么那条记录就会对 www.whispery.top 生效；如果hostname设置为home，那么就会对 home.whipery.top 生效。</p><h2 id="type-域名记录类型">TYPE 域名记录类型</h2><h3 id="a-记录">A 记录</h3><p>A 其实是 Address 的缩写，A记录是用来指定hostname对应的IP记录。</p><h3 id="aaaa-记录">AAAA 记录</h3><p>ipv6 版本的 A 记录。</p><h3 id="cname-记录">CNAME 记录</h3><p>别名记录。hostname是CNAME的别名，例如hostname为www，记录类型cname，设置的值(value)<a href="http://xn--github-h02m.io">是github.io</a>，那么就会解析 www.whispery.top 为 <a href="http://github.io">github.io</a> 的别名。</p><h3 id="mx-记录">MX 记录</h3><p>暂时没有看。</p><h3 id="ns-记录">NS 记录</h3><p>解析服务器记录。对于hostname，会使用特定值（value）的解析服务器</p><h2 id="ttl-time-to-live">TTL（Time To Live）</h2><p>域名解析记录在DNS服务器中的存留时间。</p><p>在各DNS服务器对域名进行解析后，会把解析结果留存在DNS服务器上一段时间，这段时间的长度就是TTL的值。</p><p>TTL的值是以秒为单位计算的，例如当TTL的值为3600秒时，那么当DNS服务器自保存记录后3600秒（1小时），DNS服务器就会重新向NS服务器要解析结果。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾博客 </category>
          
          <category> 计算机世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技数码 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>另一条声明</title>
      <link href="/2024/03/%E5%8F%A6%E4%B8%80%E6%9D%A1%E5%A3%B0%E6%98%8E/"/>
      <url>/2024/03/%E5%8F%A6%E4%B8%80%E6%9D%A1%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>致博客的老朋友们（虽然一个也没有）：由于一些原因，新建了一个博客，先前的博文会在后续工作中逐渐搬运回来。在这里重新描述一下这个博客。</p><span id="more"></span><h2 id="欢迎来到微语的闲庭小室">欢迎来到微语的闲庭小室！</h2><p>这里是我的闲庭小室，也是我写各种小记的地方。</p><h3 id="小记世界">小记世界</h3><p>什么是小记？小记是博主我（脑内）提出的一个文章类型，通过简洁简单的文章来记录一样简单或稍有复杂的事物。老实说，关于小记的具体形式，我并没有一个清晰的印象（概念），我只是在模仿脑内想象的模糊的形象在进行写作。不过我相信，随着写作文章数量的增加，我也许可以概况出这一形象的特点，从而得到关于小记的具体形象和要求。</p><p>之所以使用小记这种形式，是因为我一时兴起的兴趣爱好过多，但是注意力又过于分散。有时候一段时间看看这个，过段时间又抛弃了这个，盯着另一件事情看——久而久之，脑海里会堆起各种碎片化的知识和信息，而这种碎片化的、不成系统的信息在脑内更容易被清理和遗忘。为了防止看了又忘的无用功，也为了方便自己回忆，因此选择使用小记来辅助回忆看过的知识。</p><p>通过小记，我可以尝试把我看到的，我觉得有意思的东西、部分奇思异想写下来。</p><p>因为我也不知道我的注意力到底会跑到哪去，但是可以肯定的是，大概率会出现以下类别的内容：</p><ul><li>计算机相关</li><li>数学相关</li><li>游戏相关</li></ul><p>当然也可能会出现其他的，请不要因此感到意外。</p><h3 id="技术问题">技术问题</h3><p>这个博客使用了 Hexo 搭建，主题则是 butterfly，因此是静态博客。</p><p>因为是静态博客的问题，很多动态的东西需要通过各种手段来解决，比如说评论系统，点赞系统之类的。</p><p>但是我在博客甚至是网页制作方面的知识几乎是零，而且对于各种评论系统的了解是一点都不了解，因此一时半会甚至是很长一段时间内你都不会看到这个博客有评论系统。</p><p>但是如果你很想评论的话，或许你可以去这个博客部署的 Github 仓库的 issue 里进行评论。</p><h3 id="在最后">在最后</h3><p>大概就这么多，今后请多关照。</p><p><strong>那么，从小记开始吧。</strong></p><hr><h2 id="老朋友-又见面了">老朋友，又见面了</h2><p>这是第二条声明了，因为换了设备，原来的 hexo 博客数据还没有转移到新设备，因此又重新创建了一个博客，而原来的博客上的文章也会在后续陆续搬运回来。</p>]]></content>
      
      
      <categories>
          
          <category> 博客公告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 公告 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
